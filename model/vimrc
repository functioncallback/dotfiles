set nocompatible
call pathogen#incubate()
call pathogen#helptags()
filetype on
syntax on

if has('gui_macvim')

  cd ~/Projects

  let NERDTreeDirArrows=1
  let NERDTreeShowHidden=1

  au BufRead,BufNewFile *.go set filetype=go
  autocmd Filetype go setlocal ts=4 sts=4 sw=4 et!

  let g:ruby_debugger_no_maps = 1
  "let g:ruby_debugger_debug_mode = 1
  "let g:ruby_debugger_progname = 'mvim'
  "let g:ruby_debugger_default_script = 'script/rails s'

  colorscheme macvim
  set background=dark
  set gfn=Monaco:h14

  set guioptions-=l
  set guioptions-=r
  set guioptions-=L
  set guioptions-=R
  set guioptions-=T

  set cursorline
  set cursorcolumn
  hi cursorline   guibg=#222222
  hi cursorcolumn guibg=#222222

  set number                        " show line numbers
  set wildignore+=node_modules      " ignores node_modules
  set wildignore+=assets/static/img " ignores node_modules
  set ruler                         " show current position
  set showmode                      " show what mode we're currently editing in
  set showmatch                     " show matching brackets
  set list                          " show hidden chars
  set listchars=tab:▸\ ,eol:¬       " chars to be shown
  set clipboard+=unnamed            " yanks to clipboard

  set noswapfile                    " no sw?s
  set visualbell                    " no beeps
  set nospell                       " no spell checking
  set wrap!                         " no word wrapping

  set virtualedit=all               " allow the cursor to go in to 'invalid' places
  set backspace=indent,eol,start    " allow backspacing over everything in insert mode
  set iskeyword+=_,$,@,%,#          " none of these are word dividers
  set ttimeoutlen=50                " make Esc key faster
  set scrolloff=3                   " number of lines to keep off the edges of the screen when scrolling
  set textwidth=0                   " no limit for text column width

  set autoindent                    " always set autoindenting on
  set copyindent                    " copy indentation on new lines
  set smartindent                   " indent on new blocks

  set expandtab                     " expand tabs by default (overloadable per file type later)
  set smarttab                      " insert tabs on the start of a line according to shiftwidth, not tabstop
  set tabstop=2                     " tab spaces size
  set softtabstop=2                 " when hitting <BS>, pretend like a tab is removed, even if spaces
  set shiftwidth=2                  " number of spaces to use for autoindenting
  set shiftround                    " use multiple of shiftwidth when indenting with '<' and '>'

  set noignorecase                  " do not ignore case when searching
  set nogdefault                    " do not search/replace 'globally' (on a line) by default
  set smartcase                     " ignore case if search pattern is all lowercase, case-sensitive otherwise
  set hlsearch                      " highlight search terms
  set incsearch                     " show search matches as you type
  set wildmenu                      " show list instead of just completing
  set wildmode=list:longest,full    " command <Tab> completion, list matches, then longest common part, then all
  set showtabline=2                 " always show tabs

  cmap cwd lcd %:p:h
  nmap <silent> <Leader>b :CtrlPBuffer<CR>
  nmap <silent> <Leader>t :NERDTreeToggle<CR>

  "quicker access to input commands
  nnoremap ; :

  "escape key cleans search highlights
  nmap <Esc> :nohlsearch<CR>:<CR>

  "quick access to ctrl-p (aka \])
  nmap <silent> <Leader>] :CtrlP<CR>

  "quick access to clear ctrl-p cache (aka \[)
  nmap <silent> <Leader>[ :CtrlPClearCache<CR>

  "format Go code (leader + f)
  nmap <silent> <Leader>f :1,$d<CR>:r !gofmt %<CR>:1<CR>:d<CR>

  "format json (leader + j)
  nmap <silent> <Leader>j :%!python -m json.tool<CR>

  "tabs navigation (cmd + shift + arrows)
  nmap <D-S-Left> :tabprevious<CR>
  nmap <D-S-Right> :tabnext<CR>

  "splits navigation (cmd + alt + arrows)
  nmap <silent> <D-A-Up> :wincmd k<CR>
  nmap <silent> <D-A-Down> :wincmd j<CR>
  nmap <silent> <D-A-Left> :wincmd h<CR>
  nmap <silent> <D-A-Right> :wincmd l<CR>

  "create empty split related to the current one (leader + arrows)
  nmap <Leader><left>  :leftabove  vnew<CR>
  nmap <Leader><right> :rightbelow vnew<CR>
  nmap <Leader><up>    :leftabove  new<CR>
  nmap <Leader><down>  :rightbelow new<CR>

  "center search results
  nmap n nzz
  nmap N Nzz
  nmap * *zz
  nmap # #zz
  nmap g* g*zz
  nmap g# g#zz

  "move visual block (ctrl + alt + up/down)
  vmap <C-A-up> xkP'[V']
  vmap <C-A-down> xp'[V']

  "move line up/down (ctrl + alt + up/down)
  nmap <C-A-up> :call g:MoveLineUp()<CR>
  nmap <C-A-down> :call g:MoveLineDown()<CR>

  function! g:MoveLineUp()
    if &modifiable
      normal ddkP
    endif
  endfunction

  function! g:MoveLineDown()
    if &modifiable
      normal ddp
    endif
  endfunction

  "vim-ruby-debugger - not working yet
  "nmap <C-S-b> :call ruby_debugger#load_debugger() <bar> call g:RubyDebugger.toggle_breakpoint()<CR>
  "nmap <leader>v  :call ruby_debugger#load_debugger() <bar> call g:RubyDebugger.open_variables()<CR>
  "nmap <leader>m  :call ruby_debugger#load_debugger() <bar> call g:RubyDebugger.open_breakpoints()<CR>
  "nmap <leader>t  :call ruby_debugger#load_debugger() <bar> call g:RubyDebugger.open_frames()<CR>
  "nmap <leader>s  :call ruby_debugger#load_debugger() <bar> call g:RubyDebugger.step()<CR>
  "nmap <leader>f  :call ruby_debugger#load_debugger() <bar> call g:RubyDebugger.finish()<CR>
  "nmap <leader>n  :call ruby_debugger#load_debugger() <bar> call g:RubyDebugger.next()<CR>
  "nmap <leader>c  :call ruby_debugger#load_debugger() <bar> call g:RubyDebugger.continue()<CR>
  "nmap <leader>e  :call ruby_debugger#load_debugger() <bar> call g:RubyDebugger.exit()<CR>
  "nmap <leader>d  :call ruby_debugger#load_debugger() <bar> call g:RubyDebugger.remove_breakpoints()<CR>

  "ignore F1
  inoremap <F1> <ESC>
  nnoremap <F1> <ESC>
  vnoremap <F1> <ESC>
endif
